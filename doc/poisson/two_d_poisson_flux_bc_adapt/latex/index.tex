In this document we discuss the adaptive solution of a 2D Poisson problem with Neumann boundary conditions. \begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Two-\/dimensional model Poisson problem with Neumann boundary conditions}} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $D = \left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\} $. The domain boundary $ \partial D = \partial D_{Neumann} \cup \partial D_{Dirichlet} $, where $ \partial D_{Neumann} = \left\{ (x_1,x_2) | x_1=1, \ x_2\in [0,2] \right\} $. On $ \partial D_{Dirichlet}$ we apply the Dirichlet boundary conditions \[ \left. u\right|_{\partial D_{Dirichlet}}=u_0, \ \ \ \ \ \ \ \ \ \ (2) \] where the function $ u_0 $ is given. On $ \partial D_{Neumann}$ we apply the Neumann conditions \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}} = \left. \frac{\partial u}{\partial x_1}\right|_{\partial D_{Neumann}} =g_0, \ \ \ \ \ \ \ \ \ \ (3) \] where the function $ g_0 $ is given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center}  ~\newline


In two previous examples we demonstrated two approaches for the {\itshape non-\/adaptive} solution of this problem. In both cases we created a \char`\"{}bulk\char`\"{} mesh of {\ttfamily QPoisson\+Elements} and applied the flux boundary conditions by \char`\"{}attaching\char`\"{} {\ttfamily Poisson\+Flux\+Elements} to the appropriate boundaries of the \char`\"{}bulk\char`\"{} Poisson elements. In the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ first implementation}} we simply added the pointers to the flux elements to the bulk mesh; in the \href{../../two_d_poisson_flux_bc2/html/index.html}{\texttt{ second implementation}} we stored the surface and bulk elements in separate meshes and combined them to a single global mesh. We will now demonstrate that the second approach greatly facilitates the automatic problem adaptation. We use the mesh adaptation procedures of the {\ttfamily Refineable\+Quad\+Mesh} class to adapt the bulk mesh, driven by the spatial error estimates in that mesh. The flux elements are neither involved in nor adapted by the refinement process of the bulk mesh. We therefore use the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} to delete the flux elements before the adaptation, and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} to re-\/attach them once the bulk mesh has been adapted.

As in the \href{../../two_d_poisson_flux_bc2/html/index.html}{\texttt{ previous example}} we choose a source function and boundary conditions for which the function \[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ (4) \] is the exact solution of the problem.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{rotate}
\doxyfigcaption{Plot of the solution obtained with automatic mesh adaptation }
\end{DoxyImage}


Since many functions in the driver code are identical to that in the non-\/adaptive version, discussed in the \href{../../two_d_poisson_flux_bc2/html/index.html}{\texttt{ previous example}}, we only list those functions that differ. Please consult the source code \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc_adapt/two_d_poisson_flux_bc_adapt.cc}{\texttt{ two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt.\+cc }} for full details of the implementation.

\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysection{Global parameters and functions}\label{index_global}
The specification of the source function and the exact solution in the namespace {\ttfamily \mbox{\hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}}} is identical to that in the single-\/mesh version discussed in the \href{../../two_d_poisson_flux_bc/html/index.html}{\texttt{ previous example}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
The main code is virtually identical to that in the \href{../../two_d_poisson_flux_bc2/html/index.html}{\texttt{ previous non-\/adaptive example }}. The only change is the provision of an argument to the Newton solver

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   \textcolor{comment}{// Solve the problem}}
\DoxyCodeLine{   problem.newton\_solve(3);}

\end{DoxyCodeInclude}
 which indicates that the problem should be adapted up to three times.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
The problem class is very similar to that in the \href{../../two_d_poisson_flux_bc2/html/index.html\#problem}{\texttt{ non-\/adaptive implementation}}\+: The only difference is the provision of the functions {\ttfamily actions\+\_\+before\+\_\+adapt()}, {\ttfamily actions\+\_\+after\+\_\+adapt()}, {\ttfamily set\+\_\+prescribed\+\_\+flux\+\_\+pt()}, and {\ttfamily delete\+\_\+flux\+\_\+elements(...)} which we discuss in more detail below.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========= start\_of\_problem\_class=====================================}}
\DoxyCodeLine{\textcolor{comment}{/// 2D Poisson problem on rectangular domain, discretised with}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// 2D QPoisson elements. Flux boundary conditions are applied}}
\DoxyCodeLine{\textcolor{comment}{/// along boundary 1 (the boundary where x=L). The specific type of }}
\DoxyCodeLine{\textcolor{comment}{/// element is specified via the template parameter.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem}{RefineableTwoMeshFluxPoissonProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a6568980564c4e39544b1c2bcb71cf3b6}{RefineableTwoMeshFluxPoissonProblem}}(PoissonEquations<2>::PoissonSourceFctPt source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a6b1f154c77ea0c415bf171764d34302f}{\string~RefineableTwoMeshFluxPoissonProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution. DocInfo object stores flags/labels for where the}}
\DoxyCodeLine{\textcolor{comment}{ /// output gets written to}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ad9d4a3b5856839fa95f60968fabe3493}{doc\_solution}}(DocInfo\& doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve: Reset boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{ /// to the values from the exact solution.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a209506229c491a8cec4e1dce387e18c3}{actions\_before\_newton\_solve}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ab8b04db3dab6297f609a9a028b1c4473}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a10d2a67a5ac599161ddcf876b31334f6}{actions\_before\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a0140155529861f5e63ab32feece3c9b6}{actions\_after\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create Poisson flux elements on boundary b of the Mesh pointed}}
\DoxyCodeLine{\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the Mesh object pointed to by }}
\DoxyCodeLine{\textcolor{comment}{ /// surface\_mesh\_pt}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ac2eaf11cfc4dda41f97cacc2a1a1f86e}{create\_flux\_elements}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&b, Mesh* \textcolor{keyword}{const} \&bulk\_mesh\_pt,}
\DoxyCodeLine{                           Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Delete Poisson flux elements and wipe the surface mesh}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ab35087cadc6dbc7a602441b9a986d650}{delete\_flux\_elements}}(Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Set pointer to prescribed-\/flux function for all}}
\DoxyCodeLine{\textcolor{comment}{ /// elements in the surface mesh}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_aa0aeec40bbdb0649e309e51ad96e5da7}{set\_prescribed\_flux\_pt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}bulk"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh<ELEMENT>}}* \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a35746600caac7fd5b1a2ccec6beff8d6}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}surface"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a1ad7c5a406b267f2d79c52b3d347971d}{Surface\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} PoissonEquations<2>::PoissonSourceFctPt \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a0f3434b437ca4b5e6a97ecae9e826477}{Source\_fct\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}
 \mbox{[}See the discussion of the \href{../../one_d_poisson/html/index.html}{\texttt{ 1D Poisson problem}} for a more detailed discussion of the function type Poisson\+Equations$<$2$>$\+::\+Poisson\+Source\+Fct\+Pt.\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The Problem constructor}\label{index_constructor}
We create the bulk mesh and surface mesh as \href{../../two_d_poisson_flux_bc2/html/index.html\#constructor}{\texttt{ before}}. Next we create the spatial error estimator and pass it to the bulk mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_constructor=============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for Poisson problem: Pass pointer to source function.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a6568980564c4e39544b1c2bcb71cf3b6}{RefineableTwoMeshFluxPoissonProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a6568980564c4e39544b1c2bcb71cf3b6}{RefineableTwoMeshFluxPoissonProblem}}(PoissonEquations<2>::PoissonSourceFctPt source\_fct\_pt)}
\DoxyCodeLine{ :  Source\_fct\_pt(source\_fct\_pt)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup "{}bulk"{} mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_x=4;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_y=4;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_x=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_y=2.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build "{}bulk"{} mesh}}
\DoxyCodeLine{ Bulk\_mesh\_pt=\textcolor{keyword}{new} }
\DoxyCodeLine{  \mbox{\hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh<ELEMENT>}}(n\_x,n\_y,l\_x,l\_y);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create/set error estimator}}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;}

\end{DoxyCodeInclude}
 Apart from this, the problem is constructed as in the \href{../../two_d_poisson_flux_bc2/html/index.html\#constructor}{\texttt{ non-\/adaptive previous example.}}


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Create "{}surface mesh"{} that will contain only the prescribed-\/flux }}
\DoxyCodeLine{ \textcolor{comment}{// elements. The constructor just creates the mesh without}}
\DoxyCodeLine{ \textcolor{comment}{// giving it any elements, nodes, etc.}}
\DoxyCodeLine{ Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create prescribed-\/flux elements from all elements that are }}
\DoxyCodeLine{ \textcolor{comment}{// adjacent to boundary 1, but add them to a separate mesh.}}
\DoxyCodeLine{ \textcolor{comment}{// Note that this is exactly the same function as used in the }}
\DoxyCodeLine{ \textcolor{comment}{// single mesh version of the problem, we merely pass different Mesh pointers.}}
\DoxyCodeLine{ create\_flux\_elements(1,Bulk\_mesh\_pt,Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Add the two sub meshes to the problem}}
\DoxyCodeLine{ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{ build\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here. }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = Bulk\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_bound;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Leave nodes on boundary 1 free}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (b!=1)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all elements so they are fully functional}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the Poisson bulk elements to set up element-\/specific }}
\DoxyCodeLine{ \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to }}
\DoxyCodeLine{ \textcolor{comment}{// source function}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to Poisson bulk element}}
\DoxyCodeLine{   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Set the source function pointer}}
\DoxyCodeLine{   el\_pt-\/>source\_fct\_pt() = Source\_fct\_pt;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set pointer to prescribed flux function for flux elements}}
\DoxyCodeLine{ set\_prescribed\_flux\_pt();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_before_adapt}{}\doxysection{Actions before adaptation}\label{index_before_adapt}
The mesh adaptation is driven by the error estimates in the bulk elements and only performed for that mesh. The flux elements must therefore be removed before adaptation. We do this by calling the function {\ttfamily delete\+\_\+flux\+\_\+elements(...)}, and then rebuilding the {\ttfamily Problem\textquotesingle{}s} global mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}}
\DoxyCodeLine{\textcolor{comment}{/// Actions before adapt: Wipe the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a10d2a67a5ac599161ddcf876b31334f6}{RefineableTwoMeshFluxPoissonProblem<ELEMENT>::actions\_before\_adapt}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Kill the flux elements and wipe surface mesh}}
\DoxyCodeLine{ delete\_flux\_elements(Surface\_mesh\_pt);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{ rebuild\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{// end of actions\_before\_adapt}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_after_adapt}{}\doxysection{Actions after adapt}\label{index_after_adapt}
After the (bulk-\/)mesh has been adapted, the flux elements must be re-\/attached. This is done by calling the function {\ttfamily create\+\_\+flux\+\_\+elements(...)}, followed by a rebuild of the {\ttfamily Problem\textquotesingle{}s} global mesh. Finally, we set the function pointer to the prescribed flux function for each flux element.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}}
\DoxyCodeLine{\textcolor{comment}{///  Actions after adapt: Rebuild the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_a0140155529861f5e63ab32feece3c9b6}{RefineableTwoMeshFluxPoissonProblem<ELEMENT>::actions\_after\_adapt}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Create prescribed-\/flux elements from all elements that are }}
\DoxyCodeLine{ \textcolor{comment}{// adjacent to boundary 1 and add them to surfac mesh}}
\DoxyCodeLine{ create\_flux\_elements(1,Bulk\_mesh\_pt,Surface\_mesh\_pt);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{ rebuild\_global\_mesh();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set pointer to prescribed flux function for flux elements}}
\DoxyCodeLine{ set\_prescribed\_flux\_pt();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Doc refinement levels in bulk mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} min\_refinement\_level;}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} max\_refinement\_level;}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>get\_refinement\_levels(min\_refinement\_level,}
\DoxyCodeLine{                                     max\_refinement\_level); }
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}Min/max. refinement levels in bulk mesh: "{}} }
\DoxyCodeLine{      << min\_refinement\_level << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{      << max\_refinement\_level << std::endl;}
\DoxyCodeLine{ }
\DoxyCodeLine{\}\textcolor{comment}{// end of actions\_after\_adapt}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_delete_flux}{}\doxysection{Delete flux elements}\label{index_delete_flux}
This function loops over all the flux elements (i.\+e. those in the surface mesh) and deletes them and their storage.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_delete\_flux\_elements==============================}}
\DoxyCodeLine{\textcolor{comment}{/// Delete Poisson Flux Elements and wipe the surface mesh}}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ab35087cadc6dbc7a602441b9a986d650}{RefineableTwoMeshFluxPoissonProblem<ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableTwoMeshFluxPoissonProblem_ab35087cadc6dbc7a602441b9a986d650}{delete\_flux\_elements}}(Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// How many surface elements are in the surface mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = surface\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the surface elements}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Kill surface element}}
\DoxyCodeLine{   \textcolor{keyword}{delete} surface\_mesh\_pt-\/>element\_pt(e);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Wipe the mesh}}
\DoxyCodeLine{ surface\_mesh\_pt-\/>flush\_element\_and\_node\_storage();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of delete\_flux\_elements}}

\end{DoxyCodeInclude}
 {\bfseries{IMPORTANT\+:}} Note how the elements are first deleted \char`\"{}manually\char`\"{} and then \char`\"{}flushed\char`\"{} from the surface mesh, using the function {\ttfamily Mesh\+::flush\+\_\+element\+\_\+and\+\_\+node\+\_\+storage()}. This is necessary because deleting the surface mesh directly (by {\ttfamily delete} {\ttfamily surface\+\_\+mesh\+\_\+pt};) would also delete its constituent {\ttfamily Nodes} which are shared with the bulk mesh and must therefore be retained!

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before}{}\doxysection{Actions before solve}\label{index_actions_before}
This remains as \href{../../two_d_poisson_flux_bc2/html/index.html\#actions_before}{\texttt{ before. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{Post-\/processing}\label{index_doc}
This remains as \href{../../two_d_poisson_flux_bc2/html/index.html\#doc}{\texttt{ before. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create_flux}{}\doxysection{Create flux elements}\label{index_create_flux}
This remains as \href{../../two_d_poisson_flux_bc2/html/index.html}{\texttt{ before. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc_adapt/}{\texttt{ demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc_adapt/two_d_poisson_flux_bc_adapt.cc}{\texttt{ demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
