Many previous examples demonstrated {\ttfamily oomph-\/lib\textquotesingle{}s} ability to solve problems on domains with moving, curvilinear boundaries. These examples had the following common features\+:
\begin{DoxyItemize}
\item The motion of the curvilinear domain boundaries was prescribed.
\item The domain was discretised by {\ttfamily Domain} / {\ttfamily Macro\+Element} -\/ based meshes. Recall that in such meshes the function {\ttfamily Mesh\+::node\+\_\+update()} updates the position of {\itshape all} of its constituent nodes in response to changes in the shape/position of the geometric objects that define its curvilinear boundaries. The update of the nodal positions is performed on an element-\/by-\/element basis and each element determines the new positions of its nodes by referring to the {\ttfamily Macro\+Element} representation of the domain.
\item The governing equations were implemented in their Arbitrary Eulerian Lagrangian (ALE) form, in which the mesh velocity is determined from the \char`\"{}history values\char`\"{} of the nodal positions.
\end{DoxyItemize}We will now consider problems in which the position of the domain boundary is unknown and has to be determined as part of the overall solution. This situation arises, e.\+g., in free-\/surface fluid flow problems and in fluid-\/structure interaction problems. We shall explain why {\ttfamily Domain} / {\ttfamily Macro\+Element} -\/ based node update strategies are unlikely to be efficient for such problems and then introduce the \char`\"{}\+Method of Spines\char`\"{} as one of a number of sparse (and therefore more efficient) node-\/update strategies available in {\ttfamily oomph-\/lib}.

\DoxyHorRuler{0}
\hypertarget{index_why_sparse}{}\doxysection{Why we need sparse node updates}\label{index_why_sparse}
The sketch below shows a free-\/surface fluids problem in which the \char`\"{}height\char`\"{} of the fluid domain (parametrised by the scalar function $ x_2 = h(x_1) $) is unknown. The lower half of the sketch shows a body-\/fitted finite-\/element mesh (the nodes and elements are shown in dark blue) that discretises the fluid domain.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{film_sketch}
\doxyfigcaption{Sketch of a free-\/surface fluid problem. }
\end{DoxyImage}


Assume now that we have some discrete representation of the unknown free surface so that $ h(x_1) $ is approximated by a function that involves a finite number of discrete unknowns $ H_i \ (i=1,...,N_H)$ . In principle, this allows us to represent the unknown boundary by a {\ttfamily Geom\+Object} in which the unknowns $ H_i \ (i=1,...,N_H)$ play the role of \char`\"{}geometric \textbackslash{}c Data\char`\"{}, i.\+e. {\ttfamily Data} whose values determine the shape of the geometric object. Once the curvilinear boundary is represented by a {\ttfamily Geom\+Object}, the update of the nodal positions in the \char`\"{}bulk\char`\"{} mesh could be performed by the {\ttfamily Domain} / {\ttfamily Macro\+Element} -\/ based methods referred to above.

How exactly the unknowns $ H_i \ (i=1,...,N_H)$ are determined is irrelevant for the purpose of this discussion ( in free surface flow problems, the relevant equation is the kinematic free-\/surface condition discussed in \href{../../../navier_stokes/single_layer_free_surface/html/index.html\#kinematic_condition_theory}{\texttt{ another tutorial}}) -- we simply assume that there {\itshape are} some equations that determine their values. The feature we wish to focus on here is that the solution of the problem by Newton\textquotesingle{}s method requires the computation of the derivatives of {\itshape all} discrete residuals with respect to {\itshape all} unknowns in the problem. {\ttfamily oomph-\/lib\textquotesingle{}s} Navier-\/\+Stokes elements compute the element residual vectors (the residuals of the discretised momentum and continuity equations, evaluated for the current values of the unknowns), and the derivatives of these residuals with respect to the elements\textquotesingle{} velocity and pressure degrees of freedom. Clearly, the entries in the element\textquotesingle{}s residual vector also depend on the position of the element\textquotesingle{}s constituent nodes, which, in a free-\/boundary problem, are determined (via the node update function) by the unknowns $ H_i \ (i=1,...,N_H)$ that discretise the position of the free surface.

The main purpose of this example is to demonstrate the use (and the creation) of so-\/called \char`\"{}spine meshes\char`\"{}. Such meshes are similar to the {\ttfamily Macro\+Element} / {\ttfamily Domain} -\/ based meshes employed in many previous examples, in that they allow the nodal positions to be updated in response to changes in the shape of their (curvilinear) domain boundaries. The key feature of \char`\"{}spine meshes\char`\"{} is that the node update can be performed on a node-\/by-\/node basis -- this an important requirement for the efficient solution of free-\/boundary and fluid-\/structure interaction problems in which the position of the nodes in the \char`\"{}bulk mesh\char`\"{} is determined by the (unknown) position of the domain boundary. The efficient evaluation of the so-\/called \char`\"{}shape derivatives\char`\"{} (the derivatives of the residuals of the equations discretised by the elements in the \char`\"{}bulk mesh\char`\"{} with respect to the unknowns that determine the position of the domain boundary)

The idea behind spine-\/based node updates is illustrated in the sketch below. Assume that the position of the domain boundary is parametrised by a scalar function, so that, for instance, $ x_2 = h(x_1)$, where $ h(x_1)$ may have to be determined as part of the solution (e.\+g. in free-\/surface fluids problems -- the origin of the \char`\"{}\+Method of Spines\char`\"{}).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{spine_sketch}
\doxyfigcaption{Sketch of the Method of Spines. }
\end{DoxyImage}


Further, assume that the mesh topology is such that the mesh\textquotesingle{}s $ N_{node} $ nodes are distributed along $ N_{spine} $ lines that are (topologically) orthogonal to the free boundary. We refer to these lines as the \char`\"{}spines\char`\"{} and denote the \char`\"{}height\char`\"{} of the domain, measured along spine $ s $ by $ H_s \ (s=1,...,N_{spine}) $. We associate each node with a particular spine (so that node $ j $ is located on spine $ s_j$) and locate it along a fixed fraction $ \omega_j $ along \char`\"{}its\char`\"{} spine. The position of node $ j $ may therefore be written as \[ {\bf x}_j = {\bf B}_{s_j} + \omega_j \, H_{s_j} \, {\bf S}_{s_j} \ \ \ \ \ \ \ \ \ \ \ \ \ (1) \] where $ {\bf B}_s $ is the vector to the \char`\"{}base\char`\"{} of spine $ s $, and $ {\bf S}_s $ the unit vector along that spine.

A key feature of this method is that

Determining the nodal positions via the \char`\"{}\+Method of Spines\char`\"{} equation (1)

Spine-\/based node updates This document has two main parts\+:
\begin{DoxyItemize}
\item In \mbox{\hyperlink{index_part1}{Part 1\+: Flow through a channel of non-\/uniform width}} we demonstrate how to use a {\ttfamily Spine\+Mesh} 
\item In \mbox{\hyperlink{index_part2}{Part 2\+: How to create a Spine\+Mesh}} we explain the general \char`\"{}philosophy\char`\"{} behind spine-\/based node-\/updates and demonstrate their implementation.
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_part1}{}\doxysection{Part 1\+: Flow through a channel of non-\/uniform width}\label{index_part1}
\hypertarget{index_example}{}\doxysubsection{The example problem}\label{index_example}
We shall illustrate the use of {\ttfamily Spine\+Meshes} by considering the problem of steady 2D flow through a channel of non-\/uniform width.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{The steady 2D Navier-\/\+Stokes equations in a channel of non-\/uniform width.}} \end{center}  Solve \[ Re \ u_j\frac{\partial u_i}{\partial x_j} = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right), \] and \[ \frac{\partial u_i}{\partial x_i} = 0, \] in the region $ D = \left\{(x_1,x_2) \ \bigg| \ x_1 \in [0,L], x_2 \in [0,h(x_1)] \right\} $, where \[ h(x_1) = \left\{ \begin{array}{cl} H & 0 \leq x_1 \leq L_1 \\ H + A\sin\left(\frac{x_1-L_1}{L_2-L_1}\right) & L_1 \leq x_1 \leq L_2 \\ H & L_2 \leq x_1 \leq L \end{array} \right. \] shown in this sketch  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{channel_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


subject to the no-\/slip Dirichlet boundary conditions on the top and bottom rigid walls \[ \left. \mathbf{u}\right|_{\partial D_{wall}}=(0,0), \] parallel, parabolic inflow on the left inflow boundary, $ \partial D_{inflow} = \{ (x_1,x_2) \ | \ x_1=0 \}$ , \[ \left. \mathbf{u}\right|_{\partial D_{inflow}} =\left(x_2\left(H-x_2\right),0\right), \] and axially traction-\/free, parallel outflow on the outflow boundary, $ \partial D_{outflow} = \{ (x_1,x_2) \ | \ x_1=L \}$ , \[ \left. u_2\right|_{\partial D_{outflow}}=0. \]   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{Results}\label{index_results}
The figures below show the results (carpet plots of the two velocity components and the pressure, and a contour plot of the pressure distribution with superimposed streamlines), obtained from computations with Taylor-\/\+Hood and Crouzeix-\/\+Raviart elements for a channel of length $ L = 2.7$ , height $ H=1.0 $ , with deflection amplitude $ A = 0.4 $, and a Reynolds number of $ Re=100$.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{TH}
\doxyfigcaption{Plot of results computed with 2D Taylor-\/\+Hood elements. }
\end{DoxyImage}
  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{CR}
\doxyfigcaption{Plot of results computed with 2D Crouzeix-\/\+Raviart elements. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{Global parameters}\label{index_namespace}
The Reynolds number is the only parameter in this problem. As usual, we define and initialise it in a namespace\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_namespace===================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for physical parameters}}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Reynolds number}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re}}=100;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
We start by creating a {\ttfamily Doc\+Info} object to define the output directory.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_main======================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver for channel flow problem with spine mesh.}}
\DoxyCodeLine{\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{spine__channel_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set output directory}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ doc\_info.number()=0;}

\end{DoxyCodeInclude}
 When using spines, we must use elements augmented by the {\ttfamily Spine\+Element$<$\+ELEMENT$>$} class. This class, adds the functionality to be updated using the method of spines (i.\+e storing a vector of pointers to the spines and allocating equations numbers associated with the spines degrees of freedom). We build the problem using {\ttfamily Spine\+Element$<$\+Tayloor\+Hood\+Element$<$2$>$$>$}.

We now build and solve the problem with Spine-\/\+Taylor-\/\+Hood elements, then repeat for Spine-\/\+Crouzeix-\/\+Raviart elements.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Solve problem with Taylor Hood elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{//Build problem}}
\DoxyCodeLine{  \mbox{\hyperlink{classChannelSpineFlowProblem}{ChannelSpineFlowProblem<SpineElement<QTaylorHoodElement<2>}} > >}
\DoxyCodeLine{   problem;}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{// Solve the problem with automatic adaptation}}
\DoxyCodeLine{  problem.newton\_solve();}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{//Output solution}}
\DoxyCodeLine{  problem.\mbox{\hyperlink{classChannelSpineFlowProblem_a101bdeee56502231945cbac272ca21f6}{doc\_solution}}(doc\_info);}
\DoxyCodeLine{  \textcolor{comment}{// Step number}}
\DoxyCodeLine{  doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{ \} \textcolor{comment}{// end of Taylor Hood elements}}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Solve problem with Crouzeix Raviart elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// Build problem}}
\DoxyCodeLine{  \mbox{\hyperlink{classChannelSpineFlowProblem}{ChannelSpineFlowProblem<SpineElement<QCrouzeixRaviartElement<2>}} > >}
\DoxyCodeLine{   problem;}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{// Solve the problem with automatic adaptation}}
\DoxyCodeLine{  problem.newton\_solve();}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{//Output solution}}
\DoxyCodeLine{  problem.\mbox{\hyperlink{classChannelSpineFlowProblem_a101bdeee56502231945cbac272ca21f6}{doc\_solution}}(doc\_info);}
\DoxyCodeLine{  \textcolor{comment}{// Step number}}
\DoxyCodeLine{  doc\_info.number()++;}
\DoxyCodeLine{  }
\DoxyCodeLine{ \} \textcolor{comment}{// end of Crouzeix Raviart elements}}
\DoxyCodeLine{      }
\DoxyCodeLine{}
\DoxyCodeLine{     }
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_main}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
The problem class for this example is very similar to our previous \href{../../driven_cavity/html/index.html\#problem}{\texttt{ steady Navier-\/\+Stokes examples }}. We store the height of the channel as private data, this is because we need it to set the inflow boundary condition.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_problem\_class============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Channel flow through a non-\/uniform channel whose geometry is defined }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// by a spine mesh.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classChannelSpineFlowProblem}{ChannelSpineFlowProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classChannelSpineFlowProblem_a23f1b987e3395b1d101eaf3f3b5c94b2}{ChannelSpineFlowProblem}}();}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor: (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classChannelSpineFlowProblem_abdf2cc520915167d8718499459df348b}{\string~ChannelSpineFlowProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve. }}
\DoxyCodeLine{\textcolor{comment}{ /// Set velocity boundary conditions just to be on the safe side...}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classChannelSpineFlowProblem_aaf6dd8a8a472ccd938df579aba61ec97}{actions\_before\_newton\_solve}}()}
\DoxyCodeLine{  \{ }
\DoxyCodeLine{   \textcolor{comment}{// Update the mesh}}
\DoxyCodeLine{   \mbox{\hyperlink{classChannelSpineFlowProblem_a6f3a60eb5d2f2a0eccb9b40848d4387d}{mesh\_pt}}()-\/>node\_update();}
\DoxyCodeLine{}
\DoxyCodeLine{  \} \textcolor{comment}{// end\_of\_actions\_before\_newton\_solve}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classChannelSpineFlowProblem_a419a80ef3d19438f193bd7843f72446a}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classChannelSpineFlowProblem_a101bdeee56502231945cbac272ca21f6}{doc\_solution}}(DocInfo\& doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Width of channel}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{classChannelSpineFlowProblem_a6ac51c3c9d400869e694fe00452e293f}{Ly}};}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{\}; \textcolor{comment}{// end\_of\_problem\_class}}

\end{DoxyCodeInclude}
 Note that the absence of boundary conditions on the right boundary (1), causes a zero traction condition to be applied there. This implies that we should not fix a pressure degree of freedom.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The problem constructor}\label{index_constructor}
We begin by setting all the mesh parameters, and building it.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_constructor==================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for ChannelSpineFlow problem }}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classChannelSpineFlowProblem_a23f1b987e3395b1d101eaf3f3b5c94b2}{ChannelSpineFlowProblem<ELEMENT>::ChannelSpineFlowProblem}}()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction in left region }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} Nx0=3;}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction in centre region}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} Nx1=12;}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction in right region}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} Nx2=8;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} Ny=10;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction in left region}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} Lx0=0.5;}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction in centre region}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} Lx1=0.7;}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction in right region}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} Lx2=1.5;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Domain length in y-\/direction}}
\DoxyCodeLine{ Ly=1.0;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build geometric object that represents the sinusoidal bump on}}
\DoxyCodeLine{ \textcolor{comment}{// the upper wall:}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// 40\% indendentation}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} amplitude\_upper = -\/0.4*Ly;}
\DoxyCodeLine{ \textcolor{comment}{// Minimum and maximum coordinates of bump}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} zeta\_min=Lx0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} zeta\_max=Lx0+Lx1;}
\DoxyCodeLine{ GeomObject* UpperWall = }
\DoxyCodeLine{  \textcolor{keyword}{new} SinusoidalWall(Ly,amplitude\_upper,zeta\_min,zeta\_max);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build and assign mesh -\/-\/ pass pointer to geometric object}}
\DoxyCodeLine{ \textcolor{comment}{// that represents the sinusoidal bump on the upper wall}}
\DoxyCodeLine{ Problem::mesh\_pt() = \textcolor{keyword}{new} ChannelSpineMesh<ELEMENT>(Nx0,Nx1,Nx2,Ny,}
\DoxyCodeLine{                                                    Lx0,Lx1,Lx2,Ly,}
\DoxyCodeLine{                                                    UpperWall);}

\end{DoxyCodeInclude}
 We then pin the velocities on the left, top and bottom boundaries (3,2 and 0).


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here: All boundaries are Dirichlet boundaries, except on boundary 1}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (ibound!=1)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{comment}{// Loop over values (u and v velocities)}}
\DoxyCodeLine{       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>pin(i); }
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{keywordflow}{else}}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{comment}{// Parallel outflow ==> no-\/slip}}
\DoxyCodeLine{       mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>pin(1); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \} \textcolor{comment}{// end loop over boundaries}}

\end{DoxyCodeInclude}
 Finally, we pass a pointer to the Reynolds number to each element and assign the equation numbers.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// No slip on stationary upper and lower walls (boundaries 0 and 2) }}
\DoxyCodeLine{ \textcolor{comment}{// and parallel outflow (boundary 1) }}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound-\/1;ibound++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (ibound!=1)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>set\_value(i,0.0);}
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{keywordflow}{else}}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>set\_value(1,0.0);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup parabolic inflow along boundary 3:}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} ibound=3; }
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()-\/>nboundary\_node(ibound);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{double} y=mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>x(1);}
\DoxyCodeLine{   \textcolor{comment}{// Parallel, parabolic inflow}}
\DoxyCodeLine{   mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>set\_value(0,y*(Ly-\/y));}
\DoxyCodeLine{   mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>set\_value(1,0.0);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Find number of elements in mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the elements to set up element-\/specific }}
\DoxyCodeLine{ \textcolor{comment}{// things that cannot be handled by constructor: Pass }}
\DoxyCodeLine{ \textcolor{comment}{// pointer to Reynolds number}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(e));}
\DoxyCodeLine{   \textcolor{comment}{//Set the Reynolds number}}
\DoxyCodeLine{   el\_pt-\/>re\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re}};}
\DoxyCodeLine{  \} }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_part2}{}\doxysection{Part 2\+: How to create a Spine\+Mesh}\label{index_part2}
Spine-\/based meshes have their origin in free-\/surface fluid-\/mechanics problems where they were first (?) introduced by Kistler \& Scriven in their paper

\begin{center} Kistler, S.\+F. \& Scriven, L.\+E. {\ttfamily Coating Flows.\textquotesingle{}\textquotesingle{} In\+: }Computational Analysis of Polymer Processing,\textquotesingle{}\textquotesingle{} Pearson, J.\+R.\+A. \& Richardson, S.\+M. (eds.); Applied Science Publishers, London (1983). \end{center} 

{\ttfamily oomph-\/lib\textquotesingle{}s} Spine\+Meshes provide a generalisation of their node-\/update techniques.

In the past when solving a problem in a domain with curved boundaries, we have made a specific Mesh for the domain, and use a geometric object to define its curved wall(s).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{mesh}
\doxyfigcaption{Diagram of a Channel\+Spine\+Mesh, going through the process of updating its central nodes, where the heights have been changed. }
\end{DoxyImage}


To generalise this approach {\ttfamily oomph-\/lib} makes use of spines.
\begin{DoxyItemize}
\item A {\ttfamily Spine} is most easily visualised a line of a certain height, in one coordinate direction.
\item A {\ttfamily Spine\+Node} is a {\ttfamily Node} located at a certain fraction along a {\ttfamily Spine}.
\item A {\ttfamily Spine\+Mesh} is a {\ttfamily Mesh} which will update using spines.
\item A {\ttfamily Spine\+Element$<$\+ELEMENT$>$} takes a \char`\"{}normal\char`\"{} element and adds the functionality to work with spines.
\end{DoxyItemize}The creation of a {\ttfamily Spine\+Mesh} is discussed in detail below \mbox{\hyperlink{index_spine_mesh}{Making a Spine\+Mesh}}. While the picture above demonstrates the ability of Spine\+Node to individually update using the function {\ttfamily spine\+\_\+node\+\_\+update(spine\+\_\+node\+\_\+pt)}.\hypertarget{index_spine_mesh}{}\doxysubsection{Making a Spine\+Mesh}\label{index_spine_mesh}
In this example we use a {\ttfamily Spine\+Mesh} to model the domain. This mesh constitutes three regions\+: left (0), centre (1) and right (2), the left and right regions have a constant height, while in the centre region the height varies. These heights are defined by two geometric objects, a \href{../../../the_data_structure/html/classoomph_1_1StraightLine.html}{\texttt{ straight line }} and a deflected line respectively. We will discuss the necessary steps taken to create this mesh (the complete documentation for this specific mesh can be found \href{../../../the_data_structure/html/classoomph_1_1ChannelSpineMesh.html}{\texttt{ here }}).

To begin, we create a new class templated by a element and inheriting from {\ttfamily Rectangular\+Quad\+Mesh$<$\+ELEMENT$>$} and {\ttfamily Spine\+Mesh}. The latter adds the functionality needed for using Spines.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{  \textcolor{keyword}{class }ChannelSpineMesh : \textcolor{keyword}{public} RectangularQuadMesh<ELEMENT>, \textcolor{keyword}{public} SpineMesh}

\end{DoxyCodeInclude}
 All Spine\+Meshs must include a function {\ttfamily spine\+\_\+node\+\_\+update}(Spine\+Node$\ast$ spine\+\_\+node\+\_\+pt), this will describe the operations performed when updating every Spine\+Node in the mesh. First we find the Spine\+Nodes fraction along the spine.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} spine\_node\_update(SpineNode* spine\_node\_pt)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{// Get spine node's fraction along the spine}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} W = spine\_node\_pt-\/>fraction();}

\end{DoxyCodeInclude}
 We then get the local coordinate on the geometric object that defines the upper wall.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Get local coordinates}}
\DoxyCodeLine{      Vector<double> s\_wall(1);}
\DoxyCodeLine{      s\_wall[0] = spine\_node\_pt-\/>spine\_pt()-\/>geom\_parameter(0);}

\end{DoxyCodeInclude}
 Finally we use the use the local coordinate to get the position of the geometric object and set the first coordinate value of the node.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Get position vector to wall}}
\DoxyCodeLine{      Vector<double> position(2);}
\DoxyCodeLine{      spine\_node\_pt-\/>spine\_pt()-\/>geom\_object\_pt(0)-\/>position(s\_wall, position);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Set the value of y}}
\DoxyCodeLine{      spine\_node\_pt-\/>x(1) = this-\/>Ymin + W * position[1];}
\DoxyCodeLine{    \}}

\end{DoxyCodeInclude}
 We store the number of elements in the x direction in each region, the number of elements in the y direction, the lengths of each region and the height of the uniform boundary, as well as pointers to the two geometric objects.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{    /// Number of elements in the left region}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} Nx0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Number of elements in the centre region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{unsigned} Nx1;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Number of elements in the right region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{unsigned} Nx2;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Length of left region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{double} Lx0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Length of centre region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{double} Lx1;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Length of right region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{double} Lx2;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Number of spines in left region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{unsigned} Nleft\_spine;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Number of spines in centre region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{unsigned} Ncentre\_spine;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// Number of spines in right region}}
\DoxyCodeLine{\textcolor{comment}{}    \textcolor{keywordtype}{unsigned} Nright\_spine;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// GeomObject for upper wall}}
\DoxyCodeLine{\textcolor{comment}{}    GeomObject* Wall\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{    /// GeomObject for the straight upper wall}}
\DoxyCodeLine{\textcolor{comment}{}    GeomObject* Straight\_wall\_pt;}

\end{DoxyCodeInclude}
 All these details are passed to the constructor, except for the pointer to the geometric object for the uniform wall. The constructor calls the empty constructor for {\ttfamily Rectangular\+Quad\+Mesh$<$\+ELEMENT$>$}, copies these values to their storage in the mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{  ChannelSpineMesh<ELEMENT>::ChannelSpineMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& nx0,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& nx1,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& nx2,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ny,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lx0,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lx1,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lx2,}
\DoxyCodeLine{                                              \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& h,}
\DoxyCodeLine{                                              GeomObject* wall\_pt,}
\DoxyCodeLine{                                              TimeStepper* time\_stepper\_pt)}
\DoxyCodeLine{    : RectangularQuadMesh<ELEMENT>(nx0 + nx1 + nx2,}
\DoxyCodeLine{                                   ny,}
\DoxyCodeLine{                                   0.0,}
\DoxyCodeLine{                                   lx0 + lx1 + lx2,}
\DoxyCodeLine{                                   0.0,}
\DoxyCodeLine{                                   h,}
\DoxyCodeLine{                                   false,}
\DoxyCodeLine{                                   false,}
\DoxyCodeLine{                                   time\_stepper\_pt),}
\DoxyCodeLine{      Nx0(nx0),}
\DoxyCodeLine{      Nx1(nx1),}
\DoxyCodeLine{      Nx2(nx2),}
\DoxyCodeLine{      Lx0(lx0),}
\DoxyCodeLine{      Lx1(lx1),}
\DoxyCodeLine{      Lx2(lx2),}
\DoxyCodeLine{      Wall\_pt(wall\_pt)}

\end{DoxyCodeInclude}
 We then assign all the parameters for the {\ttfamily Rectangular\+Quad\+Mesh$<$\+ELEMENT$>$}, create the geometric object for the uniform wall and call the function {\ttfamily build\+\_\+channel\+\_\+spine\+\_\+mesh(...)} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{comment}{// Mesh can only be built with 2D Qelements.}}
\DoxyCodeLine{    MeshChecker::assert\_geometric\_element<QElementGeometricBase, ELEMENT>(2);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Mesh can only be built with spine elements}}
\DoxyCodeLine{    MeshChecker::assert\_geometric\_element<SpineFiniteElement, ELEMENT>(2);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// We've called the "{}generic"{} constructor for the RectangularQuadMesh}}
\DoxyCodeLine{    \textcolor{comment}{// which doesn't do much...}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Build the straight line object}}
\DoxyCodeLine{    Straight\_wall\_pt = \textcolor{keyword}{new} StraightLine(h);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Now build the mesh:}}
\DoxyCodeLine{    build\_channel\_spine\_mesh(time\_stepper\_pt);}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 When we call the function {\ttfamily build\+\_\+channel\+\_\+spine\+\_\+mesh(...)}, it calls its counterpart in the {\ttfamily Rectangular\+Quad\+Mesh$<$\+ELEMENT$>$}, then store the numbers of elements in each direction in each region (and all at once).

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{void} ChannelSpineMesh<ELEMENT>::build\_channel\_spine\_mesh(}
\DoxyCodeLine{    TimeStepper* time\_stepper\_pt)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{comment}{// Build the underlying quad mesh:}}
\DoxyCodeLine{    RectangularQuadMesh<ELEMENT>::build\_mesh(time\_stepper\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Read out the number of elements in the x-\/direction and y-\/direction}}
\DoxyCodeLine{    \textcolor{comment}{// and in each of the left, centre and right regions}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_x = this-\/>Nx;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_y = this-\/>Ny;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_x0 = this-\/>Nx0;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_x1 = this-\/>Nx1;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_x2 = this-\/>Nx2;}

\end{DoxyCodeInclude}
 We then allocate memory for the elements and spines in each region in each region.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Set up the pointers to elements in the left region}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} nleft = n\_x0 * n\_y;}
\DoxyCodeLine{    ;}
\DoxyCodeLine{    Left\_element\_pt.reserve(nleft);}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} ncentre = n\_x1 * n\_y;}
\DoxyCodeLine{    ;}
\DoxyCodeLine{    Centre\_element\_pt.reserve(ncentre);}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} nright = n\_x2 * n\_y;}
\DoxyCodeLine{    ;}
\DoxyCodeLine{    Right\_element\_pt.reserve(nright);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} irow = 0; irow < n\_y; irow++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e = 0; e < n\_x0; e++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{        Left\_element\_pt.push\_back(this-\/>finite\_element\_pt(irow * n\_x + e));}
\DoxyCodeLine{      \}}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e = 0; e < n\_x1; e++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{        Centre\_element\_pt.push\_back(}
\DoxyCodeLine{          this-\/>finite\_element\_pt(irow * n\_x + (n\_x0 + e)));}
\DoxyCodeLine{      \}}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e = 0; e < n\_x2; e++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{        Right\_element\_pt.push\_back(}
\DoxyCodeLine{          this-\/>finite\_element\_pt(irow * n\_x + (n\_x0 + n\_x1 + e)));}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{    \textcolor{comment}{// Check that we have the correct number of elements}}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (nelement() != nleft + ncentre + nright)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"{}Incorrect number of element pointers!"{}},}
\DoxyCodeLine{                          OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{                          OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Allocate memory for the spines and fractions along spines}}
\DoxyCodeLine{    \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Read out number of linear points in the element}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_p = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(finite\_element\_pt(0))-\/>nnode\_1d();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} nspine;}
\DoxyCodeLine{    \textcolor{comment}{// Allocate store for the spines:}}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (this-\/>Xperiodic)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      nspine = (n\_p -\/ 1) * n\_x;}
\DoxyCodeLine{      Spine\_pt.reserve(nspine);}
\DoxyCodeLine{      \textcolor{comment}{// Number of spines in each region}}
\DoxyCodeLine{      \textcolor{comment}{// NOTE that boundary spines are in both regions}}
\DoxyCodeLine{      Nleft\_spine = (n\_p -\/ 1) * n\_x0 + 1;}
\DoxyCodeLine{      Ncentre\_spine = (n\_p -\/ 1) * n\_x1 + 1;}
\DoxyCodeLine{      Nright\_spine = (n\_p -\/ 1) * n\_x2;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{else}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      nspine = (n\_p -\/ 1) * n\_x + 1;}
\DoxyCodeLine{      Spine\_pt.reserve(nspine);}
\DoxyCodeLine{      \textcolor{comment}{// Number of spines in each region}}
\DoxyCodeLine{      \textcolor{comment}{// NOTE that boundary spines are in both regions}}
\DoxyCodeLine{      Nleft\_spine = (n\_p -\/ 1) * n\_x0 + 1;}
\DoxyCodeLine{      Ncentre\_spine = (n\_p -\/ 1) * n\_x1 + 1;}
\DoxyCodeLine{      Nright\_spine = (n\_p -\/ 1) * n\_x2 + 1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// end Allocating memory}}

\end{DoxyCodeInclude}
 Now we allocate storage for the parameters used to build the spines.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// set up the vectors of geometric data \& objects for building spines}}
\DoxyCodeLine{    Vector<double> r\_wall(2), zeta(1), s\_wall(1);}
\DoxyCodeLine{    GeomObject* geometric\_object\_pt = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// LEFT REGION}}
\DoxyCodeLine{    \textcolor{comment}{// ===========}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// SPINES IN LEFT REGION}}
\DoxyCodeLine{    \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Set up zeta increments}}
\DoxyCodeLine{    \textcolor{keywordtype}{double} zeta\_lo = 0.0;}
\DoxyCodeLine{    \textcolor{keywordtype}{double} dzeta = Lx0 / n\_x0;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Initialise number of elements in previous regions:}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_prev\_elements = 0;}

\end{DoxyCodeInclude}
 Now we create the first Spine with unit length, pin the height (since it is not a degree of freedom in this mesh) and push the spine back onto the {\ttfamily Spine\+\_\+pt}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// FIRST SPINE}}
\DoxyCodeLine{    \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Element 0}}
\DoxyCodeLine{    \textcolor{comment}{// Node 0}}
\DoxyCodeLine{    \textcolor{comment}{// Assign the new spine with unit length}}
\DoxyCodeLine{    Spine* new\_spine\_pt = \textcolor{keyword}{new} Spine(1.0);}
\DoxyCodeLine{    new\_spine\_pt-\/>spine\_height\_pt()-\/>pin(0);}
\DoxyCodeLine{    Spine\_pt.push\_back(new\_spine\_pt);}

\end{DoxyCodeInclude}
 We then set the {\ttfamily spine\+\_\+pt()} of the first node to the Spine we just created, assign the nodes {\ttfamily fraction()} to zero and define the node as part of this mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{    SpineNode* nod\_pt = element\_node\_pt(0, 0);}
\DoxyCodeLine{    \textcolor{comment}{// Set the pointer to the spine}}
\DoxyCodeLine{    nod\_pt-\/>spine\_pt() = new\_spine\_pt;}
\DoxyCodeLine{    \textcolor{comment}{// Set the fraction}}
\DoxyCodeLine{    nod\_pt-\/>fraction() = 0.0;}
\DoxyCodeLine{    \textcolor{comment}{// Pointer to the mesh that implements the update fct}}
\DoxyCodeLine{    nod\_pt-\/>spine\_mesh\_pt() = \textcolor{keyword}{this};}

\end{DoxyCodeInclude}
 We then mark the node as part of the left (0) region.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{comment}{// Set update fct id}}
\DoxyCodeLine{    nod\_pt-\/>node\_update\_fct\_id() = 0;}

\end{DoxyCodeInclude}
 When we built the Spine, we set its height to 1.\+0. We now need to assign its height from the {\ttfamily Straight\+\_\+wall\+\_\+pt} and assign all the information needed to update the mesh to the Spine.

First we set the value of $\zeta$ and get the geometric object and the local coordinate.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Provide spine with additional storage for wall coordinate}}
\DoxyCodeLine{    \textcolor{comment}{// and wall geom object:}}
\DoxyCodeLine{}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{// Get the Lagrangian coordinate in the Lower Wall}}
\DoxyCodeLine{      zeta[0] = 0.0;}
\DoxyCodeLine{      \textcolor{comment}{// Get the geometric object and local coordinate}}
\DoxyCodeLine{      Straight\_wall\_pt-\/>locate\_zeta(zeta, geometric\_object\_pt, s\_wall);}

\end{DoxyCodeInclude}
 Then we store these geometric parameters in the Spine.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// The local coordinate is a geometric parameter}}
\DoxyCodeLine{      \textcolor{comment}{// This needs to be set (rather than added) because the}}
\DoxyCodeLine{      \textcolor{comment}{// same spine may be visited more than once}}
\DoxyCodeLine{      Vector<double> parameters(1, s\_wall[0]);}
\DoxyCodeLine{      nod\_pt-\/>spine\_pt()-\/>set\_geom\_parameter(parameters);}

\end{DoxyCodeInclude}
 We then set the height of the Spine according to the geometric object.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Get position of wall}}
\DoxyCodeLine{      Straight\_wall\_pt-\/>position(s\_wall, r\_wall);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Adjust spine height}}
\DoxyCodeLine{      nod\_pt-\/>spine\_pt()-\/>height() = r\_wall[1];}

\end{DoxyCodeInclude}
 Finally we set the Spines\textquotesingle{} pointer to the geometric object.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// The sub geom object is one (and only) geom object}}
\DoxyCodeLine{      \textcolor{comment}{// for spine:}}
\DoxyCodeLine{      Vector<GeomObject*> geom\_object\_pt(1);}
\DoxyCodeLine{      geom\_object\_pt[0] = geometric\_object\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// Pass geom object(s) to spine}}
\DoxyCodeLine{      nod\_pt-\/>spine\_pt()-\/>set\_geom\_object\_pt(geom\_object\_pt);}
\DoxyCodeLine{    \}}

\end{DoxyCodeInclude}
 Now we loop vertically along the spine, adding a pointer to the spine to each element, and assigning the fraction for each node on this spine, define each node as part of this mesh, and mark it as part of the left region.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Loop vertically along the spine}}
\DoxyCodeLine{    \textcolor{comment}{// Loop over the elements}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i = 0; i < n\_y; i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{// Loop over the vertical nodes, apart from the first}}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} l1 = 1; l1 < n\_p; l1++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{        \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{        SpineNode* nod\_pt = element\_node\_pt(i * n\_x, l1 * n\_p);}
\DoxyCodeLine{        \textcolor{comment}{// Set the pointer to the spine}}
\DoxyCodeLine{        nod\_pt-\/>spine\_pt() = new\_spine\_pt;}
\DoxyCodeLine{        \textcolor{comment}{// Set the fraction}}
\DoxyCodeLine{        nod\_pt-\/>fraction() =}
\DoxyCodeLine{          (double(i) + double(l1) / double(n\_p -\/ 1)) / \textcolor{keywordtype}{double}(n\_y);}
\DoxyCodeLine{        \textcolor{comment}{// Pointer to the mesh that implements the update fct}}
\DoxyCodeLine{        nod\_pt-\/>spine\_mesh\_pt() = \textcolor{keyword}{this};}
\DoxyCodeLine{        \textcolor{comment}{// Set update fct id}}
\DoxyCodeLine{        nod\_pt-\/>node\_update\_fct\_id() = 0;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \} \textcolor{comment}{// end loop over elements}}

\end{DoxyCodeInclude}
 We then loop over the remaining spines in the left region repeating this process, except that the first spine in each element (except the first) is copied from the last spine in the previous element.

We then repeat this process for the centre and right regions, using the correct geometric objects to define the upper wall, which can be examined in detail \href{../../../the_data_structure/html/classoomph_1_1ChannelSpineMesh.html}{\texttt{ here }}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_exercises}{}\doxysubsection{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Investigate what happens when a pressure degree of freedom is fixed.
\item Try creating a new geometric object, which creates a triangular indentation in the central region of the upper wall as shown.
\end{DoxyEnumerate}

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{Exercise}
\doxyfigcaption{Plot of the solution to the problem specified in the above exercise computed with 3x3 Taylor-\/\+Hood elements and Re=100. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
