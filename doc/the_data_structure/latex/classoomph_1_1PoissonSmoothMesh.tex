\hypertarget{classoomph_1_1PoissonSmoothMesh}{}\doxysection{oomph\+::Poisson\+Smooth\+Mesh\texorpdfstring{$<$}{<} POISSON\+\_\+\+ELEMENT \texorpdfstring{$>$}{>} Class Template Reference}
\label{classoomph_1_1PoissonSmoothMesh}\index{oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$@{oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$}}


///////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////  




{\ttfamily \#include $<$mesh\+\_\+smooth.\+h$>$}

Inheritance diagram for oomph\+::Poisson\+Smooth\+Mesh\texorpdfstring{$<$}{<} POISSON\+\_\+\+ELEMENT \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classoomph_1_1PoissonSmoothMesh}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classoomph_1_1PoissonSmoothMesh_ad0a3d661fd2048fa4967e68ffeb1d630}{operator()}} (\mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} $\ast$orig\+\_\+mesh\+\_\+pt, std\+::set$<$ Node $\ast$ $>$ pinned\+\_\+nodes)
\begin{DoxyCompactList}\small\item\em Functor\+: Specify \mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} whose nodal positions are to be adjusted, and set of nodes in that mesh whose position are to remain fixed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class POISSON\+\_\+\+ELEMENT$>$\newline
class oomph\+::\+Poisson\+Smooth\+Mesh$<$ POISSON\+\_\+\+ELEMENT $>$}
///////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////// 

Functor to smooth a \mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} by adjusting the internal nodal positions by solving a Poisson problem for the nodal displacements in the interior. The displacements of the specified pinned nodes (usually located on boundaries) remain fixed (their displacements are computed from the difference between their Lagrangian and Eulerian coordinates). The assumptions is that the Lagrangian coordinates in the \mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} still reflect the original nodal positions before the boundary nodes were moved. ~\newline
The template parameter specifies the Poisson element that must have the same shape (geometric element type) as the elements contained in the mesh that\textquotesingle{}s to be smoothed. So, e.\+g. for the ten-\/noded three-\/dimensional tetrahedral TTaylor\+Hood\+Element$<$3$>$, it would be a TPoisson\+Element$<$3,3$>$, etc. 

Definition at line \mbox{\hyperlink{mesh__smooth_8h_source_l00658}{658}} of file \mbox{\hyperlink{mesh__smooth_8h_source}{mesh\+\_\+smooth.\+h}}.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classoomph_1_1PoissonSmoothMesh_ad0a3d661fd2048fa4967e68ffeb1d630}\label{classoomph_1_1PoissonSmoothMesh_ad0a3d661fd2048fa4967e68ffeb1d630}} 
\index{oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$@{oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$}!operator()@{operator()}}
\index{operator()@{operator()}!oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$@{oomph::PoissonSmoothMesh$<$ POISSON\_ELEMENT $>$}}
\doxysubsubsection{\texorpdfstring{operator()()}{operator()()}}
{\footnotesize\ttfamily template$<$class POISSON\+\_\+\+ELEMENT $>$ \\
void \mbox{\hyperlink{classoomph_1_1PoissonSmoothMesh}{oomph\+::\+Poisson\+Smooth\+Mesh}}$<$ POISSON\+\_\+\+ELEMENT $>$\+::operator() (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} $\ast$}]{orig\+\_\+mesh\+\_\+pt,  }\item[{std\+::set$<$ Node $\ast$ $>$}]{pinned\+\_\+nodes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Functor\+: Specify \mbox{\hyperlink{classoomph_1_1SolidMesh}{Solid\+Mesh}} whose nodal positions are to be adjusted, and set of nodes in that mesh whose position are to remain fixed. 



Definition at line \mbox{\hyperlink{mesh__smooth_8h_source_l00664}{664}} of file \mbox{\hyperlink{mesh__smooth_8h_source}{mesh\+\_\+smooth.\+h}}.



References \mbox{\hyperlink{mesh_8h_source_l00617}{oomph\+::\+Mesh\+::add\+\_\+element\+\_\+pt()}}, \mbox{\hyperlink{mesh_8h_source_l00611}{oomph\+::\+Mesh\+::add\+\_\+node\+\_\+pt()}}, \mbox{\hyperlink{problem_8cc_source_l01989}{oomph\+::\+Problem\+::assign\+\_\+eqn\+\_\+numbers()}}, \mbox{\hyperlink{elements_8h_source_l02514}{oomph\+::\+Finite\+Element\+::construct\+\_\+node()}}, \mbox{\hyperlink{cfortran_8h_source_l00571}{e}}, \mbox{\hyperlink{mesh_8h_source_l00473}{oomph\+::\+Mesh\+::finite\+\_\+element\+\_\+pt()}}, \mbox{\hyperlink{cfortran_8h_source_l00603}{i}}, \mbox{\hyperlink{problem_8h_source_l01280}{oomph\+::\+Problem\+::mesh\+\_\+pt()}}, \mbox{\hyperlink{mesh_8h_source_l00590}{oomph\+::\+Mesh\+::nelement()}}, \mbox{\hyperlink{problem_8cc_source_l08783}{oomph\+::\+Problem\+::newton\+\_\+solve()}}, \mbox{\hyperlink{elements_8h_source_l02215}{oomph\+::\+Finite\+Element\+::nnode()}}, \mbox{\hyperlink{mesh_8h_source_l00596}{oomph\+::\+Mesh\+::nnode()}}, \mbox{\hyperlink{elements_8h_source_l02180}{oomph\+::\+Finite\+Element\+::node\+\_\+pt()}}, \mbox{\hyperlink{mesh_8h_source_l02594}{oomph\+::\+Solid\+Mesh\+::node\+\_\+pt()}}, \mbox{\hyperlink{oomph__definitions_8cc_source_l00319}{oomph\+::oomph\+\_\+info}}, \mbox{\hyperlink{mesh_8cc_source_l09564}{oomph\+::\+Solid\+Mesh\+::set\+\_\+lagrangian\+\_\+nodal\+\_\+coordinates()}}, and \mbox{\hyperlink{nodes_8h_source_l01884}{oomph\+::\+Solid\+Node\+::xi()}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{mesh__smooth_8h}{mesh\+\_\+smooth.\+h}}\end{DoxyCompactItemize}
